**C++中的模板：**

  **函数模板**：是一些被参数化的函数，代表的是一个函数家族。可以用多种不同的数据类型进行调用，其外表看起来和普通的函数很相似的，唯一的区别在于就是有些函数元素是没有确定的。下面是一些简答的例子：

```cpp
template <typename T>
inline T const& max (T const& a, T const& b)
{
  return a < b ? b : a;
}
```

  在上面的程序中类型参数是T，可以使用任何标识符作为类型参数的名称，但是一般都是使用T，类型参数可以是任何的类型，但是其中的对应的数据类型必须支持：```operator<``` 才可以。

  同时还可以使用关键字```class```取代其中的```typename```，但是为了不带来迷惑，我个人建议还是使用```typename```的方式更好的！使用```class```只是历史原因，所以一般还是不要用，否则会让人觉得可以使用```struct```的值来取代其中的```typename```迷惑性很强！

```cpp
int main()
{
  int a = ::max(7, 2);
  double b = ::max(8.9, 9.2);
}
```

  每次调用之前都是一个域限定符```::```，因为在```std```中也有一个max的函数，一般指代明确一些会比较好！

  **实例化**：即使用具体的数据类型代替模板参数的过程，会生成一个模板的实列。

```cpp
inline int const& max (int const& a, int const& b)
{
  return a < b ? b : a;
}
```

**实参演绎**：在实参的演绎中是不允许出现自动类型转换，只要是同一个T申明的变量对应的每个T都必须相同才可以！

**模板参数**：

  模板参数：位于函数模板名称前面，在一对<>中进行声明的：```template<typename T>```

  调用参数：位于函数模板名称之后，在一对圆括号内部进行声明。

  ```...max(T const& a, T const& b)```//其中的a 跟 b都是调用参数！

只要是你声明了不同的数据类型作为对应的函数的参数的数据类型的时候，对应的必须在实例化的时候指定对应的满足对应的特定的数据类型的函数参数的值！如果你在对应的函数返回的参数中使用了模板参数的时候，那么必须在实例化的时候进行指定，因为模板参数的演绎是无法得到对应的返回参数的类型。

**重载函数模板**：

```cpp
inline int const& max(int const& a, int const& b)
{
    return a < b ? a : b;
}
template <typename T>
inline T const& max(T const& a, T const& b)
{
    return a < b ? a : b;
}
template <typename T>
inline T const& max(T const& a, T const& b, T const& c)
{
    return ::max(c, ::max(a, b));
}
```

**总结：**

1. ​	模板函数为不同的模板实参定义了一个函数家族
2. ​    当你传递模板实参得到时候，可以根据实参的类型来对函数模板进行实例化
3. ​    可以显示的指定模板的参数
4. ​    可以重载函数模板
5. ​    当重载函数模板的时候，把对应的改变限制在显示的指定模板参数
6. ​    一定要让函数模板的所有重载版本的声明都位于他们的被调用的位置之前的