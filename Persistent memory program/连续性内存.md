更多资料见： http://pmem.io

​	书中认为当问固态硬盘上的数据是简单而且容易理解的，专注于内存型访问，应用程序驻留在持久内存中的字节可寻址数据结构！本书的技术可以保证数据结构在连续性内存中是能够存留下于电路故障或者电源短缺，本书中描述的技术可以使这些数据结构在这些事件之间保持一致。 

  持久性内存：是一类支持字节寻址，可以通过CPU指令直接进行操作、断电后数据不丢失的存储硬件。就是说其可以直接插在内存插槽上，直接通过内存总线和CPU通信，同时CPU也可以通过特定的指令直接访问对应的内存！

​	**持久内存的目标一直是将更多的数据移动到更靠近CPU的位置，从而获得DRAM级别的低延迟以及存储级别的持久性和容量**。

​	快于其它的原因是多方面的：

1. 首先其不需要将内存进行再CPU与外存之间传入传出处理
2. 其的内存大小是大于其中的DRAM的。也就是内存越大可以存储的东西更大的，其可以往的data的容量更大！很显然可以减少磁盘的I/O次数。

一些具体的性能指标：

​	

#### Persistent Memory Architecture

​	本章概述了持久内存体系结构，同时重点介绍了硬件，以强调开发人员需要了解的需求和决策。

 	设计用于识别系统中持久内存存在的应用程序可以比使用其他存储设备运行得更快，因为数据不必在CPU和较慢的存储设备之间来回传输。**因为只使用持久内存的应用程序可能比动态随机存取内存慢**，所以它们应该决定哪些数据驻留在动态随机存取内存、持久内存和存储中。

​	**持久内存的容量预计比DRAM大很多倍**；**因此，应用程序可以就地存储和处理的数据量也要大得多**。这大大减少了磁盘输入/输出的数量，从而提高了性能并减少了存储介质的磨损。

​	**在没有永久内存的系统上，无法装入动态随机存取存储器的大型数据集必须分段处理或流式传输**。这会导致处理延迟，因为应用程序会停止等待从磁盘分页或从网络流式传输数据。

​	**如果工作数据集的大小在持久内存和动态随机存取存储器的容量范围内，应用程序可以执行内存中的处理，而不需要检查点或页面数据进出存储**。这显著提高了性能。

#### Persistent Memory Characteristics：一些特征

​	就像每一项新技术一样，总有新的东西需要考虑。持久内存也不例外。设计和开发解决方案时，请考虑以下特征:

- 持久内存的性能(吞吐量、延迟和带宽)比与NAND好得多，但可能比动态随机存取存储器DRAM慢。
- 持久内存不像动态随机存取存储器那样耐用。它的耐用性通常比NAND好几个数量级，应该超过服务器的寿命而不会磨损。
- 持久内存模块的容量可以比动态内存大得多，并且可以共存于同一个内存通道中。
- 支持持久内存的应用程序可以就地更新数据，而无需序列化/反序列化数据。
- 持久内存像内存一样是字节可寻址的。应用程序只能更新所需的数据，没有任何读-修改-写开销。
- 数据是CPU缓存一致的。
- 持久内存提供直接内存访问和远程内存访问(RDMA)操作。
- 断电时，写入永久存储器的数据不会丢失。
- 权限检查完成后，位于永久内存中的数据可以从用户空间直接访问。数据路径中没有内核代码、文件系统页面缓存或中断。
- 永久内存中的数据立即可用，即:
  - 一旦系统通电，数据就可用。
  - 应用程序不需要花时间预热缓存。他们可以在内存映射后立即访问数据。
  - 除非应用程序将数据复制到动态随机存取存储器以实现更快的访问，否则驻留在永久存储器上的数据没有动态随机存取存储器空间。
- 写入永久内存模块的数据是系统本地的。应用程序负责跨系统复制数据。

####  Platform Support for Persistent Memory

​	英特尔、AMD、ARM等平台供应商将决定如何在最低硬件级别实现持久内存。我们试图提供一个与供应商无关的视角，并且只是偶尔调用特定于平台的细节。

​	对于具有持久内存的系统，故障原子性保证了系统在电源或系统故障后总能恢复到一致的状态。应用程序的故障原子性可以通过日志记录、刷新和内存存储屏障来实现。无论是撤消还是重做，日志记录都可以在故障中断最后一个原子操作完成时确保原子性。缓存刷新确保易失性缓存中保存的数据到达持久性域，这样，如果发生突然故障，数据不会丢失。内存存储障碍，如x86体系结构上的SFENCE操作，有助于防止内存层次结构中的潜在重新排序，因为缓存和内存控制器可能会对内存操作进行重新排序。例如，一个屏障确保在实际数据被修改之前，数据的撤消日志副本被持久化到持久内存中。这保证了如果发生故障，最后一个原子操作可以回滚。然而，在具有低级操作(如写日志记录、缓存刷新和屏障)的用户应用程序中添加这种故障原子性并不重要。开发持久内存开发工具包(PMDK)是为了让开发人员不必重新实现复杂的硬件。

​	故障原子性应该是一个熟悉的概念，因为大多数文件系统实现并执行日志记录，并将其元数据刷新到存储设备。

#### Cache Hierarchy：

​	我们使用加载和存储操作来读写永久内存，而不是使用基于块的输入/输出来读写传统存储。我们建议阅读CPU架构文档进行深入描述，因为每一代CPU都可能引入新的功能、方法和优化。

​	以英特尔架构为例，中央处理器高速缓存通常有三个不同的级别:L1、L2和L3。该层次结构引用了与CPU内核的距离、速度和缓存大小。L1缓存最靠近中央处理器。它速度极快，但非常小。L2和L3缓存的容量越来越大，但速度相对较慢。图2-1显示了一个典型的CPU微体系结构，具有三级CPU缓存和一个具有三个内存通道的内存控制器。每个内存通道都连接了一个动态随机存取存储器和永久内存。在CPU缓存不包含在电源故障保护域中的平台上，当系统断电或崩溃时，CPU缓存中任何未刷新到永久内存的修改数据都将丢失。如果系统崩溃或断电，在断电保护域中包含CPU缓存的平台将确保CPU缓存中的修改数据被刷新到永久内存中。我们在即将到来的“电源故障保护域”一节中描述了这些要求和功能。

![image-20210507202212356](C:\Users\guiyuan\AppData\Roaming\Typora\typora-user-images\image-20210507202212356.png)

​	L1(1级)高速缓存是计算机系统中最快的内存。就访问优先级而言，L1缓存拥有CPU在完成特定任务时最有可能需要的数据。L1高速缓存通常也分为两种方式，指令高速缓存(L1一号)和数据高速缓存(L1四号)。指令高速缓存处理关于CPU必须执行的操作的信息，而数据高速缓存保存要对其执行操作的数据。	

​	L2(2级)缓存的容量大于L1缓存，但速度较慢。L2缓存保存下一步可能被中央处理器访问的数据。在大多数现代中央处理器中，L1和L2高速缓存存在于中央处理器内核本身，每个内核都有专用的高速缓存。

​	L3(3级)缓存是最大的缓存内存，但也是三者中最慢的。它也是CPU上所有内核之间的通用共享资源，并且可以在内部进行分区，以允许每个内核都有专用的L3资源。

​	从动态随机存取存储器或永久存储器读取的数据通过存储器控制器传输到三级高速缓存，然后传播到L2高速缓存，最后到L1高速缓存，在那里中央处理器核心消耗它。当处理器在寻找数据以执行某项操作时，它首先会尝试将其查找到L1缓存中。如果CPU能找到，这种情况称为缓存命中。如果中央处理器在L1高速缓存中找不到数据，则依次会去L2和L3中查找。如果它在这三个中的任何一个都找不到数据，它会尝试从内存中访问它。每次在缓存中找不到数据都被称为缓存未命中。无法在内存中定位数据要求操作系统将数据从存储设备分页到内存中。

​	当中央处理器写入数据时，数据最初会写入L1缓存。由于中央处理器中正在进行的活动，在某个时间点，数据将从L1缓存中被逐出到L2缓存中。数据可以进一步从L2逐出，并放入L3，最终从L3逐出到存储器控制器的写缓冲区，然后在那里写入存储器设备。

​	在没有永久内存的系统中，软件通过将数据写入非易失性存储设备(如固态硬盘、硬盘、存储区域网络、网络连接存储或云中的卷)来保存数据。这可以保护数据免受应用程序或系统崩溃的影响。可以使用 msync()、fsync() 或 fdatasync() 等调用手动刷新关键数据，这些调用将未提交的脏页从易失性内存刷新到非易失性存储设备。如果需要，文件系统提供fdisk或chkdsk实用程序来检查和尝试修复损坏的文件系统。文件系统不能保护用户数据免受损坏。应用程序有责任检测这种情况并从中恢复。例如，这就是为什么数据库使用各种技术，如事务更新、重做/撤消日志记录和校验和。

​	应用程序内存将持久内存地址范围直接映射到自己的内存地址空间。因此，应用程序必须承担检查和保证数据完整性的责任。本章的其余部分描述了您在持久内存环境中的职责，以及如何实现数据一致性和完整性。

#### Power-Fail Protected Domains

​	计算机系统可以包括一个或多个中央处理器、易失性或持久性存储器模块以及非易失性存储设备，例如固态硬盘或硬盘。

​	系统平台硬件支持持久性域的概念，也称为电源故障保护域。根据平台的不同，持久性域可能包括持久性内存控制器和写队列、内存控制器写队列和CPU缓存。一旦数据到达持久性域，在系统重新启动的过程中，它可能是可恢复的。也就是说，如果数据位于受电源故障保护的硬件写队列或缓冲区内，域应用程序应该假设它是持久的。例如，如果发生电源故障，使用平台为此目的所保证的存储能量从断电保护域中恢复。尚未进入受保护域的数据将会丢失。

​	同一个系统中可能存在多个持久性域，例如，在具有多个物理CPU的系统上。系统还可以提供一种机制来划分平台资源以便隔离。这必须以这样一种方式完成，即从每个兼容的卷或文件系统保证SNIA  NVM编程模型的行为。(第3章描述了应用于操作系统和文件系统的编程模型。该章中的“检测平台功能”部分描述了应用程序应该执行的逻辑，以检测平台功能，包括电源故障保护域。后面的章节将深入讨论应用程序应该刷新数据的原因、方式和时间(如果需要)，以确保数据在受保护的域和持久内存中是安全的。)

​	当计算机系统电源中断时，易失性存储器会丢失其内容。就像非易失性存储设备一样，即使在没有系统电源的情况下，持久内存也能保存其内容。物理保存到永久存储介质的数据称为静态数据。in-flight数据有以下含义:

- 发送到永久内存设备但尚未物理提交到介质的写入
- 任何正在进行但尚未完成的写入
- 暂时缓冲或缓存在中央处理器缓存或内存控制器中的数据

​     当系统正常重新启动或关闭时，系统会保持电源，并确保刷新CPU缓存和内存控制器的所有内容，以便将任何正在传输或未提交的数据成功写入永久内存或非易失性存储。当发生意外的电源故障时，假设没有不间断电源可用，系统必须在电源和周围分布的电容器中存储足够的能量，以便在电源完全耗尽之前刷新数据。任何未刷新的数据都将丢失且不可恢复。

​	异步动态随机存取存储器刷新(ADR)是英特尔产品支持的一项功能，它刷新写保护数据缓冲区，并将动态随机存取存储器置于自刷新状态。在断电事件或系统崩溃期间，此过程至关重要，以确保数据在持久内存中处于安全一致的状态。默认情况下，ADR不会刷新处理器缓存。支持ADR的平台仅包括持久性内存和持久性域中内存控制器的写挂起队列。

​	增强型异步动态随机存取存储器刷新(eADR)要求在ADR事件开始之前调用不可屏蔽中断(NMI)例程来刷新CPU缓存。运行在eADR平台上的应用程序不需要执行刷新操作，因为硬件应该自动刷新数据，但它们仍然需要执行SFENCE操作来保持写顺序的正确性。商店只有在全球可见的情况下才被认为是持久的，这是SFENCE所保证的。

![image-20210507203733339](C:\Users\guiyuan\AppData\Roaming\Typora\typora-user-images\image-20210507203733339.png)

​	ADR是永久内存的强制性平台要求。一旦接收到所有数据，存储器控制器内的写入挂起队列(WPQ)向写入器确认数据的接收。尽管数据尚未写入永久介质，但支持ADR的平台可以保证在断电事件发生时成功写入。在崩溃或电源故障期间，只有当平台支持eADR时，才能保证通过CPU缓存传输的数据被刷新到持久媒体。在只支持ADR的平台上会丢失。

​	将持久性域扩展到包括CPU高速缓存的挑战在于，CPU高速缓存相当大，并且比典型电源中的电容器实际能够提供的能量要多得多。这意味着该平台必须包含电池或使用外部不间断电源。支持持久内存的每台服务器都需要电池，这通常不切实际，也不划算。电池的寿命通常比服务器短，这引入了额外的维护程序，减少了服务器的正常运行时间。使用电池还会对环境产生影响，因为电池必须正确处理或回收。服务器或电器原始设备制造商完全有可能在其产品中包含电池。

​	因为一些设备和服务器供应商计划使用电池，并且因为平台有朝一日将在持久性域中包括CPU缓存，所以在ACPI有一个属性是可用的，这样当可以跳过CPU刷新时，BIOS可以通知软件。在带有eADR的平台上，不需要手动刷新缓存行。

#### The Need for Flushing, Ordering, and Fencing

​	除了WBINVD这种只支持内核模式的操作外，表2-1中的机器指令(在“英特尔持久内存机器指令”一节中)在用户空间中受到英特尔和AMD  CPUs的支持。英特尔采用SNIA非易失性存储器编程模型来处理持久内存。该模型允许使用字节可寻址操作(即加载/存储)的直接访问(DAX)。但是，在数据进入持久性域之前，不能保证数据在缓存中的持久性。x86体系结构提供了一组指令，用于以更优化的方式刷新缓存行。除了现有的x86指令，如非时态存储、CLFLUSH和WBINVD，增加了两个新的指令:CLFLUSHOPT和CLWB。两个新指令之后必须有一个SFENCE，以确保在继续之前完成所有刷新。用户空间支持使用CLWB、CLFLUSHOPT或CLFLUSH刷新缓存行和使用非临时存储。您可以在该架构的软件开发人员手册中找到每条机器指令的详细信息。例如，在英特尔平台上，该信息可以在英特尔64和32架构软件开发人员手册中找到。

​	非时态存储意味着正在写入的数据不会很快被再次读取，因此我们绕过了CPU缓存。也就是说，没有时间局部性，所以将数据保存在处理器的高速缓存中没有好处，并且如果存储的数据从高速缓存中置换出其他有用的数据，可能会有损失。

​	直接从用户空间刷新到持久内存否定了对内核的调用，这使得它非常高效。该特性在SNIA持久内存编程模型规范中被记录为优化刷新。

​	根据硬件和操作系统支持，文档1将优化刷新描述为可选地由平台支持。尽管有中央处理器的支持，当操作系统表明可以安全使用时，应用程序只使用优化的刷新是非常重要的。操作系统可能需要像msync()这样的调用所提供的控制点，例如，当需要作为msync()操作的一部分写入文件系统元数据时。

​	为了更好地理解指令排序，考虑一个非常简单的链表例子。下面描述的伪代码有三个简单的步骤，将新节点添加到已经包含两个节点的现有列表中。这些步骤如图2-3所示。

- 创建新节点(node 2)。
- 更新节点指针(下一个指针)以指向列表中的最后一个节点(node 2  → node 1)。
- 将头指针更新为指向新节点(head→node 2)。

​      图2-3(步骤3)显示了在CPU缓存版本中更新了头指针，但是节点2到节点1的指针还没有在持久内存中更新。这是因为硬件可以选择提交哪些缓存行，并且顺序可能与源代码流不匹配。如果系统或应用程序在这一点上崩溃，持久内存状态将是不一致的，数据结构将不再可用。

![image-20210508144708537](C:\Users\guiyuan\AppData\Roaming\Typora\typora-user-images\image-20210508144708537.png)

​	

Chapter 3:

​	图3-6显示了本章描述的操作系统支持的完整视图。正如我们所讨论的，应用程序可以使用持久内存作为快速固态硬盘，更直接地通过持久内存感知文件系统，或者使用DAX选项直接映射到应用程序的内存空间。DAX利用内存映射文件的操作系统服务，但利用服务器硬件将持久内存直接映射到应用程序地址空间的能力。这避免了在主存储器和存储器之间移动数据的需要。接下来的几章描述了在持久内存中直接处理数据的注意事项，然后讨论了简化开发的应用编程接口。

#### Chapter 4: Fundamental Concepts  of Persistent Memory  Programming

​	在第3章中，您看到了操作系统如何将持久内存作为内存映射文件公开给应用程序。本章建立在这个基本模型的基础上，并研究了出现的编程挑战。理解这些挑战是持久内存编程的一个重要部分，尤其是在设计应用程序因崩溃和电源故障等问题而中断后的恢复策略时。但是，不要让这些挑战阻止你进行持久内存编程！第5章描述了如何利用现有的解决方案来节省您的编程时间并降低复杂性

 **What’s Different?**

​	应用程序开发人员通常根据驻留在内存中的数据结构和驻留在存储中的数据结构进行思考。对于数据中心应用程序，开发人员会小心翼翼地在存储上维护一致的数据结构，即使面临系统崩溃。这个问题通常通过日志记录技术来解决，例如预写日志记录，其中更改首先被写入日志，然后被刷新到持久存储。如果数据修改过程中断，应用程序在日志中有足够的信息来完成重启操作。像这样的技术已经存在很多年了；然而，正确的实现很难开发，维护起来也很耗时。开发人员通常依赖数据库、库和现代文件系统的组合来提供一致性。尽管如此，最终还是应用开发人员负责设计策略，在运行时以及从应用程序和系统崩溃中恢复时，在存储上维护一致的数据结构。

​	与存储驻留数据结构不同，应用程序开发人员关心的是在运行时保持内存驻留数据结构的一致性。当一个应用程序有多个线程访问同一个数据结构时，就使用像锁定这样的技术，这样一个线程就可以对数据结构进行复杂的更改，而另一个线程只能看到部分更改。当应用程序退出或崩溃时，或者系统崩溃时，内存内容就消失了，所以不需要像存储驻留数据结构那样在应用程序运行之间保持内存驻留数据结构的一致性。

​	这些解释可能看起来很明显，但这些假设，即存储状态在运行之间保持不变，内存内容是不稳定的，在应用程序开发的方式中是如此的基本，以至于大多数开发人员都没有考虑太多。**持久内存的不同之处当然是它是持久的，所以存储和内存的所有考虑都适用**。应用程序负责在运行和重启之间维护一致的数据结构，以及与内存驻留数据结构一起使用的线程安全锁定。

​	如果持久内存和存储一样有这些属性和要求，为什么不把多年开发的代码用于存储呢？这种方法确实有效；在持久内存上使用存储API是我们在第3章中描述的编程模型的一部分。如果持久内存上现有的存储API足够快，能够满足应用程序的需求，那么就不需要做进一步的工作。但是为了充分利用持久内存的优势，在持久内存中，数据结构在适当的位置被读取和写入，访问发生在字节粒度，而不是使用块存储堆栈，应用程序将希望内存映射它并直接访问它。这消除了数据路径中基于缓冲区的存储应用编程接口。

​	Atomic Updates：

​	每个支持持久内存的平台都有一组原子的本地内存操作。在英特尔硬件上，原子持久存储是8字节。因此，如果程序或系统在与持久内存对齐的8字节存储运行时崩溃，那么在恢复时，这8个字节将包含旧内容或新内容。英特尔处理器具有存储超过8字节的指令，但这些指令不是故障原子指令，因此它们可能会被电源故障等事件破坏。 有时，对驻留在内存中的数据结构的更新需要多条指令，因此这些更改自然也会因电源故障而被破坏，因为任何两条指令之间都会断电。运行时锁定防止其他线程看到部分完成的更改，但是锁定不提供任何失败原子性。当应用程序需要对持久内存进行大于8字节的更改时，它必须通过构建硬件提供的基本原子性来构建原子操作，例如英特尔硬件提供的8字节故障原子性。

Transactions：事务

​	将多个操作组合成单个原子操作通常被称为事务。在数据库世界中，首字母缩略词ACID描述了事务的属性:原子性、一致性、隔离性和持久性。

#### 原子性：

​	如前所述，原子性是指将多个操作组合成一个原子动作，该动作要么完全发生，要么根本不发生，即使面对系统故障也是如此。对于持久内存，最常用的技术有：

- Redo logging 其中完整的更改首先写入日志，因此在恢复期间，如果中断，它可以前滚。
- Undo logging 其中记录了允许在恢复期间回滚部分完成的更改的信息。
- Atomic pointer updates 其中通过原子地更新单个指针来激活改变，通常将指针从指向旧数据改变为指向新数据。

​    前面的列表并不详尽，它忽略了可能变得相对复杂的细节。一个常见的考虑是，事务通常包括内存分配/解除分配。例如，向树数据结构添加节点的事务通常包括新节点的分配。如果事务回滚，必须释放内存以防止内存泄漏。现在想象一个事务执行多个持久内存分配和自由操作，所有这些都必须是同一个原子操作的一部分。这个事务的实现显然比仅仅将新值写入日志或更新一个指针更复杂。

####  Consistency:

​	一致性意味着事务只能将数据结构从一种有效状态移动到另一种有效状态。对于持久内存，程序员通常会发现，他们用来进行线程安全更新的锁定通常也表示一致性点。如果一个线程看到中间状态是无效的，那么锁定可以防止这种情况的发生，并且当解除锁定是安全的时候，这是因为另一个线程观察数据结构的当前状态是安全的。

####  Isolation:

​	多线程(并发)执行在现代应用程序中很常见。在进行事务性更新时，隔离是允许并发更新具有相同效果的因素，就好像它们是按顺序执行的一样。在运行时，持久内存更新的隔离通常通过锁定来实现。由于内存是持久的，所以当应用程序中断时，必须考虑正在进行的事务的隔离。持久性内存程序员通常会在重启时检测到这种情况，并在允许通用线程访问数据结构之前，适当地向前或向后滚动部分完成的事务。

#### Durability:

​	如果事务完成时位于持久性介质上，则该事务被认为是持久的。即使此时系统断电或崩溃，事务仍会完成。如第2章所述，这通常意味着更改必须从中央处理器缓存中清除。这可以使用标准的应用程序接口来完成，比如Linux的msync()调用，或者特定于平台的指令，比如Intel的CLWB。在持久性内存上实现事务时，请小心确保在更改开始之前将日志条目刷新到持久性，并在事务被认为完成之前将更改刷新到持久性。持久属性的另一个方面是能够在应用程序启动时再次找到持久信息。这是存储工作的基础，我们认为这是理所当然的。文件名和目录名等元数据用于查找应用程序在存储上的持久状态。对于持久内存，由于第3章中描述的编程模型，情况也是如此，其中持久内存是通过首先在直接访问(DAX)文件系统上打开一个文件，然后内存映射该文件来访问的。然而，内存映射文件只是一系列原始数据；

​	应用程序如何找到驻留在该范围内的数据结构？对于持久内存，必须至少有一个众所周知的数据结构位置作为起点。这通常被称为根对象(在第7章中描述)。PMDK的许多高级图书馆都使用根对象来访问数据。



 Flushing Is Not Transactional:刷新不是事务性的！

​	将刷新到持久性的想法与事务性更新分开是很重要的。使用像Linux上的msync()或fsync()和Windows上的FlushFileBuffers()这样的调用来刷新对存储的更改从未提供事务性更新。除了刷新存储更改之外，应用程序还负责维护一致的存储数据结构。有了持久的记忆，也是如此。在第3章中，一个简单的程序将一个字符串存储到持久内存中，然后刷新它以确保更改是持久的。但这些代码不是事务性的，面对失败，变化几乎可以是任何状态——从完全丢失到部分丢失到完全完成。

​	缓存的一个基本属性是，它们临时保存数据以提高性能，但通常在事务准备提交之前不会保存数据。正常的系统活动可能会造成缓存压力，并随时以任何顺序驱逐数据。如果第3章中的例子因电源故障而中断，则存储的字符串的任何部分都可能丢失，任何部分都可能以任何顺序持续存在。重要的是要将缓存刷新操作视为刷新任何尚未刷新的内容，而不是现在刷新我的所有更改。

​	最后，我们在第2章展示了一个决策树(图2-5)，其中应用程序可以在启动时确定持久内存不需要缓存刷新。例如，在出现电源故障时自动刷新CPU缓存的平台上，可能会出现这种情况。即使在不需要刷新指令的平台上，事务仍然需要在失败时保持数据结构的一致性。

####  Start-Time Responsibilities：

​	在第2章(图2-5和2-6)，我们展示了流程图，概述了应用程序在使用持久内存时的职责。这些职责包括检测平台细节、可用指令、介质故障等。对于存储，这些类型的事情发生在操作系统的存储堆栈中。持久性内存，但是，允许直接访问，一旦文件被内存映射，就将内核从数据路径中移除。

​	作为一名程序员，您可能会想映射持久内存并开始使用它，如第3章的例子所示。对于生产质量编程，您希望确保满足这些开始时的责任。例如，如果您跳过图2-5中的检查，您将会得到一个即使在不需要时也能刷新CPU缓存的应用程序，并且在不需要刷新的硬件上运行不佳。如果您跳过图2-6中的检查，您将有一个忽略媒体错误的应用程序，并且可能使用损坏的数据，导致不可预测和未定义的行为。

####  Tuning for Hardware Configurations：

​	将大型数据结构存储到持久内存时，有几种方法可以复制数据并使其持久化。您可以使用通用存储操作复制数据，然后刷新缓存(如果需要)，或者使用特殊指令，如英特尔绕过CPU缓存的非临时存储指令。另一个需要考虑的问题是，持久内存写入性能可能比写入正常内存慢，因此您可能希望采取措施尽可能高效地存储到持久内存，方法是在将多个小的写入内容存储到持久内存之前，将其合并到较大的更改中。持久内存的最佳写入大小将取决于它所插入的平台和持久内存产品本身。这些例子表明，不同的平台在使用持久内存时会有不同的特性，任何生产质量的应用程序都会被调整为在预期的目标平台上表现最佳。自然，帮助进行这种调优工作的一种方法是利用已经调优和验证过的库或中间件。

- Atomic updates
- Flushing is not transactional
- Star-time responsibilities
- Tuning for hardware configurations

​	在生产质量应用程序中处理这些挑战需要一些复杂的编程和大量的测试和性能分析。下一章将介绍持久内存开发工具包，它旨在帮助应用程序开发人员解决这些挑战。



#### Chapter 5 : Introducing the Persistent  Memory Development Kit

​	前面几章介绍了持久内存的独特性质，这使得它很特别，你认为为这样一种新颖的技术编写软件是复杂的，这是正确的。任何研究或开发过持久内存代码的人都可以证明这一点。为了让您的工作更轻松，英特尔开发了持久内存开发套件(PMDK)。PMDK开发团队设想它是所有持久内存的标准库，为持久内存编程的常见挑战提供解决方案。

#### Background: [pmem/pmdk: Persistent Memory Development Kit (github.com)](https://github.com/pmem/pmdk)

​	PMDK已经发展成为应用程序开发人员和系统管理员的开源库和工具的大集合，以简化对持久存储设备的管理和访问。它是随着操作系统中对持久内存的支持而发展起来的，这确保了库利用了通过操作系统接口公开的所有功能。

​	PMDK库建立在SNIA非易失性存储器编程模型(在第3章中描述)的基础上。他们对其进行了不同程度的扩展，有些是通过简单地将操作系统暴露的原语包装成易于使用的函数，有些是通过提供复杂的数据结构和算法供持久内存使用。这意味着您有责任就哪个抽象级别最适合您的用例做出明智的决定。

​	虽然PMDK是由英特尔创建的，以支持其硬件产品，但英特尔致力于确保库和工具是供应商和平台中立的**。这意味着PMDK不依赖于英特尔处理器或英特尔持久存储设备**。它可以在任何其他通过操作系统公开必要接口的平台上工作，包括Linux和微软Windows。我们欢迎并鼓励个人、硬件供应商和独立软件开发商为PMDK做出贡献。PMDK有一个BSD  3条款许可证，允许开发人员将其嵌入任何软件，无论是开源的还是专有的。这允许您通过只集成所需的代码位来挑选PMDK的各个组件。

 Choosing the Right Semantics：选择正确的语义

PMDK有这么多库，仔细考虑你的选择是很重要的。**PMDK提供两种库类别**:

- ​	**易失性库是为那些只希望利用持久内存容量的用例准备的。**Volatile libraries are for use cases that only wish to exploit the capacity of persistent memory.
- ​     **持久库用于希望实现故障安全持久存储算法的软件。**Persistent libraries are for use in software that wishes to  implement fail-safe persistent memory algorithms

​    当你决定如何最好地解决一个问题时，仔细考虑它属于哪一类。故障安全持久程序所面临的挑战与易变程序有很大不同。提前选择正确的方法可以最大限度地降低重写任何代码的风险。

​	根据特性和功能需求，您可以决定将这两个类别的库用于应用程序的不同部分。

Volatile Libraries：

​	易失性库通常更容易使用，因为当永久内存不可用时，它们可以退回到动态随机存取存储器。这提供了更直接的实现。根据工作负载的不同，与类似的持久性库相比，它们的总体开销可能更低，因为它们不需要在出现故障时确保数据的一致性。

​	本节探讨了应用程序中易变用例的可用库，包括什么是库以及何时使用它。这些库可能有重叠的用例。

libmemkind? what is it?

​	memkind库，称为libmemkind，是一个用户可扩展的堆管理器，建立在jemalloc之上。它能够控制内存特性，并在不同类型的内存之间划分堆。内存的种类由应用于虚拟地址范围的操作系统内存策略定义。没有用户扩展的memkind支持的内存特性包括控制非均匀内存访问(NUMA)和页面大小特性。jemalloc非标准接口已被扩展，以使专门的种类能够通过memkind分区接口从操作系统请求虚拟内存。通过其他memkind接口，您可以控制和扩展内存分区功能，并在选择启用功能的同时分配内存。memkind接口允许您使用PMEM类型从持久内存中创建和控制文件备份内存。在第十章中详细的描述了这一块的内容！

When to use it ?

​	当您希望在保留传统编程模型的同时，手动将选定的内存对象移动到易失性应用程序的持久内存中时，请选择libmemkind。memkind库提供了熟悉的malloc()和free()语义。对于持久性内存的大多数易变用例，这是推荐的内存分配器。

​	现代内存分配器通常依靠匿名内存映射来从操作系统提供内存页面。对于大多数系统，这意味着实际物理内存仅在首次访问页面时分配，从而允许操作系统过度配置虚拟内存。此外，如果需要，可以调出匿名内存。当对基于文件的种类(如PMEM种类)使用memkind时，物理空间仍然只在第一次访问页面时分配，其他描述的技术不再适用。当没有可分配的内存时，内存分配将会失败，因此在应用程序中处理此类失败非常重要。

​	所描述的技术在隐藏手动动态内存分配的固有低效(例如碎片)方面也发挥了重要作用，当没有足够的连续可用空间时，手动动态内存分配会导致分配失败。因此，对于具有不规则分配/解除分配模式的应用程序，基于文件的类型可能会表现出较低的空间利用率。libvmemcache可能更适合这类工作负载。

 libvmemcache:

​	